package indalo.walsh;

import java.text.DecimalFormat;

public class Hadamard {

   /**
    * Performs a fast Walsh transformation using a Hadamard (natural) ordered
    * in-place algorithm. Array x is altered by this algorithm. If you want the
    * result in a new array, leaving the input data intact, use the
    * fwt(double[]) method instead.
    * <p>
    * Note that this transform is its own inverse, to within a scale factor of
    * x.length, because the transform matrix is orthogonal and symmetric about
    * its diagonal. An interesting implication is that the j(th) factorial
    * design point can be generated by creating a vector of all zeros except for
    * a one in location (j-1), then performing an fwt on the vector. Repeating
    * for j=1,...,2^k yields a full factorial design for k factors
    */
   public static double[] ipfwt(double[] x) {
      double temp;
      int j;
      int k;
      int offset;
      int ngroups;

      if (!isPowerOf2(x.length)) {
         throw new IllegalArgumentException(
               "Vector length must be a power of two.");
      }
      for (int lag = 1; lag < x.length; lag = offset) {
         offset = lag << 1;
         ngroups = x.length / offset;
         for (int group = 0; group < ngroups; ++group) {
            for (int base = 0; base < lag; ++base) {
               j = base + group * offset;
               k = j + lag;
               temp = x[j];
               x[j] += x[k];
               x[k] = temp - x[k];
            }
         }
      }
      return x;
   }

   /**
    * Performs a Hadamard ordered Fast Walsh Transform. This method is a
    * front-end which clones the argument array, then operates on the clone
    * in-place. Returns the resulting vector of Walsh coefficients.
    */
   public static double[] fwt(double[] x) {
      return ipfwt((double[]) x.clone());
   }

   /*
    * Private method to check whether n is a power of two
    */
   private static boolean isPowerOf2(int n) {
      final int MAXINT = 1 << 30;
      for (int i = 1; i < MAXINT; i <<= 1)
         if (i == n)
            return true;
      return false;
   }

   /*
    * Private method to format an output string to a fixed with by prepending
    * space
    */
   private static String prependSpace(int n, String s) {
      String[] res = { "", " ", "  ", "   ", "    " };
      if (n < res.length)
         return res[n] + s;
      else
         return s;
   }

   /*
    * Main method to demonstrate/test the algorithm. Generates fractional factorial
    * factor settings based on pre-calculated Walsh indices from Sanchez & Sanchez.
    * User should specify the number of factors as a command line argument.
    * Program defaults to 5 factors if no input was provided.
    */
   public static void main(String[] args) {
      String s;
      int[] index = {1, 2, 4, 8, 15, 16, 32, 51, 64, 85, 106, 128, 150, 171,
            219, 237, 247, 256, 279, 297, 455, 512, 537, 557, 594, 643, 803,
            863, 998, 1024, 1051, 1070, 1112, 1169, 1333, 1345, 1620, 1866,
            2048, 2076, 2085, 2185, 2372, 2456, 2618, 2800, 2873, 3127, 3284,
            3483, 3557, 3763, 4096, 4125, 4135, 4174, 4435, 4459, 4469, 4497,
            4752, 5255, 5732, 5804, 5915, 6100, 6369, 6907, 7069, 8192, 8263,
            8351, 8422, 8458, 8571, 8750, 8858, 9124, 9314, 9500, 10026,
            10455, 10556, 11778, 11885, 11984, 13548, 14007, 14514, 14965,
            15125, 15554, 16384, 16457, 16517, 16609, 16771, 16853, 17022,
            17453, 17891, 18073, 18562, 18980, 19030, 19932, 20075, 20745,
            21544, 22633, 23200, 24167, 25700, 26360, 26591, 26776, 28443,
            28905, 29577, 32705};
      int[] power = new int[index.length];
      for (int i = 0, p = 1; i < index.length; ++i) {
         if (index[i] >= p) p <<= 1;
         power[i] = p;
      }
      int size = (args.length > 0) ? Integer.parseInt(args[0]) : 5;
      double[][] design = new double[size][];
      DecimalFormat decimal0 = new DecimalFormat("###0;-##0");
      DecimalFormat decimalX = new DecimalFormat("'X'##0");
      System.out.print(" run#");
      for (int i = 1; i <= size; ++i) {
         s = decimalX.format(i);
         System.out.print(prependSpace(5 - s.length(), s));
      }
      System.out.println();
      for (int i = 0; i < size; ++i) {
         design[i] = new double[power[size-1]];
         design[i][index[i]] = 1.0;
         Hadamard.ipfwt(design[i]);
      }
      for (int j = 0; j < power[size-1]; ++j) {
         s = decimal0.format(j + 1);
         System.out.print(prependSpace(5 - s.length(), s));
         for (int i = 0; i < design.length; ++i) {
            s = decimal0.format(design[i][j]);
            System.out.print(prependSpace(5 - s.length(), s));
         }
         System.out.println();
      }
   }
}
